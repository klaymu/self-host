<!doctype html>
<html lang="en">
<meta encoding="utf-8">
<style>
    :root {
        font-family: Calibri, sans-serif;
        color: lightgray;
        background-color: black;
        max-width: 100ch;
        margin: auto;
    }
    a {
        color: deepskyblue;
    }
    a:visited {
        color: deeppink;
    }
    code {
        color: lightgreen;
        font-size: 1rem;
    }
    section {
        border-top: lightgray solid 0.5ch;
    }
</style>
<h1>klay mu's quick guide to self-hosting, v0.4.3</h1>

<section>
<h2>materials</h2>
<p>
    this website is hosted on a <a href=
    "https://www.raspberrypi.com/">Raspberry Pi</a>, but if those aren't available where and when you are, a good alternative is the <a href="https://www.pine64.org/devices/single-board-computers/rock64/">ROCK64</a>. you'll also need a MicroSD card and an external hard drive, I recommend 64GB and 2TB respectively.
</p>
</section>

<section>
<h2>operating system</h2>
<p>
    first, go ahead and install whatever flavor of linux you're going to use, I recommend <a href="https://www.armbian.com/">armbian</a>. follow the installation steps for your device. you may need to plug in an external keyboard and monitor for this step. the installation should walk you through creating a new username and password, I recommend a <a href="https://xkcd.com/936/">long but memorable phrase</a>.
</p>
<p>
    after installing the os is a good time do to some initial setup. while you're connected as root, update your installed packages:
    <br>
    <code># apt update</code>
    <br>
    <code># apt upgrade</code>
</p>
<p>
    set your hostname, this is how you will appear to other computers on the network. for this example I'll use 'teapot'.
    <br>
    <code># hostnamectl set-hostname teapot</code>
    <br>
    I'd like to be able to connect to this hostname via LAN, too. there's a tool for this called 'avahi-daemon'.
    <br>
    <code># apt install avahi-daemon</code>
</p>
<p>
    this is a good time to reboot, to make sure the updated hostname is in use:
    <br>
    <code># reboot</code>
</p>
<p>
    you should now be able to ssh into the server from another machine, with
    <br>
    <code>ssh yourname@teapot</code>
    <br>
    or
    <br>
    <code>ssh yourname@teapot.local</code>
</p>
</section>

<section>
<h2>format storage</h2>
<p>
    the Raspberry Pi and the ROCK64 both use a MicroSD card as the operating system disk. it's clever; if the os breaks you can just pull its brain out, factory reset it, and pop it back in. however, I don't want to store all my user data on that brain card. I think it's better if you have a secondary disk that contains <em>only</em> the stuff you create yourself. that way if something goes wrong and you have to reset the brain card, you don't lose any of your pictures or music or whatever.
</p>
<p>
    there are different formats for a data disk. the format determines exactly where the data and metadata will appear in each 'chunk' on the disk. windows typically uses <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>, which supports metadata for ownership and modified time, but not for fine-grained access like whether guests are allowed to open the file in read-only mode. linux uses a format that does allow this fine-grained access, called <a href="https://en.wikipedia.org/wiki/Ext4">ext4</a>, so that's what we need to format our data disk as.
</p>
<p>
    <strong>⚠️ warning! this will erase everything on the disk!</strong>
</p>
<p>
    first we need to identify the disk's device file. in linux, everything you can read or write to is treated as a file, including a usb device like an external disk. note that this device file is not the same as a filesystem mount. we'll cover mounting later.
</p>
<p>
    unplug the disk. run the command <code>fd</code>. plug the disk back in. run <code>fd</code> again, and compare its output to before. there should be exactly one new entry, and it should look like <code>/dev/sda</code> or <code>/dev/sdb2</code>. if you're not sure which disk it is, don't risk it, phone a friend. 
</p>
<p>
    format the disk:
    <br>
    <code>$ sudo mkfs.ext4 /dev/sda</code>
    <br>
    and label it:
    <br>
    <code>$ sudo e2label /dev/sda teapot-data</code>
</p>
</section>

<section>
<h2>mount storage</h2>
<p>
    Linux doesn't use drive letters like Windows does. Instead, every disk's filesystem lives at some <em>path</em>. the "main" path is <code>/</code>, a single slash, and usually belongs to the main disk, in this case the MicroSD card. we'll create a new path at <code>/data</code> for our data disk.
</p>
<p>
    <code>$ sudo mkdir /data</code>
</p>
<p>
    when the system boots up, it looks in the system file <code>/etc/fstab</code> to find out what disks live at what paths. since we gave our disk a label earlier, we can mount it using that label. 
</p>
<p>
    edit fstab:
    <br>
    <code>$ sudo nano /etc/fstab</code>
    <br>
    <br>
    add this line:
    <br>
    <code>LABEL=teapot-data /data ext4 nofail,x-systemd.device-timeout=5s,x-systemd.automount 0 0</code>
</p>
<p>
    there's a lot going on here. you can <a href="https://www.freedesktop.org/software/systemd/man/systemd.mount.html#fstab">read more</a> about how fstab and systemd work together, but basically what we're saying is:
</p>
<ul>
    <li>find the disk labeled "teapot-data" and mount it at /data, as an ext4 filesystem.</li>
    <li>nofail: if the disk is missing at boot time, skip it and finish booting anyway.</li>
    <li>x-systemd.device-timeout=5s: wait 5 seconds before giving up.</li>
    <li>x-systemd.automount: if someone tries to access the disk and it's not mounted, try mounting it again.</li>
</ul>
<p>
    we're using a delayed mounting process here because we want to make sure our server still comes online, even if the disk fails to load. if the server crashed on boot we'd have to go physically plug in a keyboard and monitor to fix it. with nofail, we can still log in remotely.
</p>
<p>
    save and exit the file if you haven't already, then check it:
    <br>
    <code>$ sudo mount --all --fake --verbose</code>
</p>
<ul>
    <li>all: apply all the rules from <code>/etc/fstab</code>.</li>
    <li>fake: don't <em>actually</em> apply the rules, just check that they're written correctly.</li>
    <li>verbose: give detailed feedback. if you leave this off, and all the mount rules are correct, then you will be rewarded with... nothing. by default, Linux programs typically say nothing unless there is an error. no news is good news, <a href="https://www.youtube.com/watch?v=DPwAsKJwLyk">I suppose.</a></li>
</ul>
<p>
    if all your mounts pass inspection, now is a good time to reboot the machine:
    <br>
    <code>$ sudo reboot now</code>
</p>
</section>

<section>
    <h2>apps</h2>
    <p>
        <code>$ sudo apt install podman uidmap slirp4netns</code>
    </p>
    <p>
        <strong>todo</strong> install an app with podman
    </p>
</section>

<!-- <section>
<h2>web</h2>
<p>
    install nginx web server
    <br>
    <code>$ sudo apt install nginx</code>
</p>
<p>
    host your static web content
    <br>
    <code>$ sudo mv /var/www/html /data/web</code>
    <br>
    <code>$ sudo ln -s /data/web /var/www/html</code>
</p>
</section>

<section>
<h2>database</h2>
<p>
    <strong>todo</strong> install mariadb database service
</p>
</section> -->

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>klay’s simple cookbook for Linux, v0.8.0-r2</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<nav>
<a href="/">home</a>
</nav>
<header id="title-block-header">
<h1 class="title">klay’s simple cookbook for Linux, <a href="https://github.com/klaymu/self-host">v0.8.0-r2</a></h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">introduction</a></li>
<li><a href="#materials">materials</a></li>
<li><a href="#usernames-and-passwords">usernames and passwords</a></li>
<li><a href="#operating-system">operating system</a></li>
<li><a href="#format-storage">format storage</a></li>
<li><a href="#mount-storage">mount storage</a></li>
<li><a href="#backups">backups</a></li>
<li><a href="#website">website</a></li>
</ul>
</nav>
<section id="introduction" class="level2">
<h2>introduction</h2>
<section id="why-a-cookbook" class="level3">
<h3>why a cookbook?</h3>
<p>there’s an old <a href="https://reddit.com/r/geek/comments/4zl3e1/happy_birthday_linux_heres_your_cake">joke</a> that using Linux is like ordering a cake and receiving a bunch of flour, sugar, butter, and eggs. many self-hosting tutorials read like the back of a box of cake mix, which is great if you want a cake fast, but unsatisfying if you want to learn about cake making. my goal is for this guide to teach you enough to improvise, to make substitutions.</p>
</section>
<section id="why-all-the-lowercase" class="level3">
<h3>why all the lowercase?</h3>
<p>a few people have asked me this. honestly I have some <a href="https://seximal.net">influences</a> but the main reason is that it reminds me of writing code. in code, uppercase letters are almost always reserved for names. I did my best to capitalize all names in this document the way their owners capitalize them, so the web protocol is HTTP, but the comic strip is xkcd.</p>
</section>
<section id="who-is-your-audience" class="level3">
<h3>who is your audience?</h3>
<p>this guide is for you if:</p>
<ul>
<li>you’re me, and you forgot how you did this last time.</li>
<li>you want to share pictures and videos and don’t want to use a commercial file host.</li>
<li>you want to run a communal server, like <a href="https://tilde.club">tilde.club</a>.</li>
<li>you’re just curious about Linux and servers!</li>
</ul>
<p>sound good? then let’s get cooking.</p>
</section>
</section>
<section id="materials" class="level2">
<h2>materials</h2>
<p>I’ll be using a <a href="https://www.raspberrypi.com">Raspberry Pi 4b</a> and installing [Raspberry Pi OS]. it’s also known as Raspbian, since it’s based on <a href="https://www.debian.org/doc">Debian</a> Linux. any Debian-like OS will work for this tutorial. if the Raspberry Pi isn’t available where and when you are, some good alternatives are the <a href="https://libre.computer/products/roc-rk3328-cc">Renegade</a> or the <a href="https://www.pine64.org/devices/single-board-computers/rock64">ROCK64</a>, running <a href="https://www.armbian.com">armbian</a> Linux.</p>
<p>you’ll also need a MicroSD card, a hard drive, and a second hard drive for backup. I recommend a 64GB MicroSD card and two 2TB hard drives. the Pi can power one hard drive via USB, but if you want to plug both in at once you’ll need a powered hard drive enclosure or a powered USB hub.</p>
<p>you can also adapt these directions to existing hardware you may already own, like an old laptop or desktop pc. you can also rent a virtual machine from a remote datacenter! the cheapest virtual machine on <a href="https://www.digitalocean.com">DigitalOcean</a> right now (as of 2023 July) costs 6 USD per month, and comes with 25GB of storage. renting a machine in a datacenter means you gget the perks of high-speed internet all day and night, which is great if you are running a game server and need a fast connection. however, you’ll pay 10 USD per month for each 100GB of additional storage, so it’s not great if you want to host a huge media archive.</p>
<!-- todo: what about S3-compatible storage? -->
</section>
<section id="usernames-and-passwords" class="level2">
<h2>usernames and passwords</h2>
<p>at some point you’ll probably want to make your server available on the internet. there are bots out there that do nothing but guess random usernames and passwords all day, and they <em>will</em> find you, so you need to be prepared.</p>
<p>for your username, pick something short and catchy. in my experience, a typical linux username is from 3 to 8 characters long. if you have a short name like ‘alice’ or ‘bob’ you can use that. if you have a nickname online like ‘azure’ or ‘luna’ then that works too. if you have a middle name, you can use your initials, like ‘jfk’. your username should be all lowercase.</p>
<p>for your password, the most important factor is length. I know you’ve been told that you need to add weird symbols and stuff in it, but that rule is for older more limited systems. it’s the 64-bit era, baby! the only thing that matters is how much entropy your password has. <strong>entropy</strong> is basically a measure of how unlikely something is to happen twice. like if I flip ten coins and you flip ten coins and we get the same sequence, the odds of that happening are 1 in 2^10, so we say that that particular sequence of flips has 10 “bits” of entropy. it’s recommended that your password have about 60 to 80 bits of entropy. yikes, that’s a lot of coin flips to memorize!</p>
<p>luckily there’s a better way. using a tool like <a href="https://xkpasswd.net/s/">xkpasswd</a> or <a href="https://theworld.com/~reinhold/diceware.html">diceware</a>, you can convert randomness into words. using the diceware list, you can roll 25 six-sided dice to get a random 25-digit sequence, and then convert each 5 digits into a word, to get a 5-word phrase. the odds of two people getting the same 5-word phrase are 1 in 6^25, which is approximately equal to 2^64, so this password has 64 bits of entropy. that’s enough to make most hackers give up and move onto an easier target. go generate a password now, and save it somewhere safe, like a password manager program, or a piece of paper tucked inside a book. don’t be afraid to write things down; you can’t hack a piece of paper.</p>
</section>
<section id="operating-system" class="level2">
<h2>operating system</h2>
<p>time to download and install your operating system. there are lots of guides on how to install Linux already, <a href="https://www.raspberrypi.com/documentation/computers/getting-started.html">here’s</a> one for Raspbian. I’ll be using "Raspberry Pi OS Lite (64-Bit), with the default settings. with these settings, there is no remote login available; you will need to plug a keyboard and monitor directly into the pi. on the first boot, you’ll be prompted to enter the username and password for the initial user. after that, you’ll be given a login prompt. log in with the username and password you just set. some operating systems display nothing at a password prompt, not even stars. once you log in, you’ll see some system information, and then a prompt that looks like</p>
<pre><code>user@raspberrypi:~ $</code></pre>
<p>this is a <strong>CLI</strong>, a command line interface. from left to right, this contains</p>
<ul>
<li>your name</li>
<li>the machine’s name</li>
<li>your current directory. <code>~</code> means “home”, and is short for <code>/home/user</code>.</li>
<li>a command prompt. this will be <code>$</code> if you are in user mode, or <code>#</code> if you are in admin mode.</li>
</ul>
<p>if you’ve ever used a bot in a chatroom, you already know how to use a command line interface! it’s a system where you type an instruction, and the computer answers you. here are some examples of commands you can type:</p>
<ul>
<li><code>whoami</code>: ask the computer what your name is.</li>
<li><code>hostname</code>: ask the computer what <em>its</em> name is.</li>
<li><code>pwd</code>: ask the computer where you are.</li>
<li><code>ls</code>: look at the files in your current location.</li>
<li><code>cd &lt;somewhere&gt;</code>: go somewhere else.</li>
<li><code>echo &lt;something&gt;</code>: ask the computer to repeat something back to you.</li>
<li><code>nano &lt;filename&gt;</code>: edit a text file.</li>
<li><code>cat &lt;filename&gt;</code>: print a text file to the screen.</li>
</ul>
<p>if this is your first time using a command line interface, try some of these commands now. use <code>nano myfile.txt</code> to open a text file, write some text to it, then save with ctrl-o, and exit with ctrl-x. use <code>ls</code> to look at that file, then use <code>cat myfile.txt</code> to have the computer read it back to you. pat yourself on the back, you’re learning so much!</p>
<p>soon we’ll unplug the keyboard and monitor from this computer, making it a ‘headless’ server. before we can do that we need to run a few commands as administrator, or ‘root’. we’ll do this with a very powerful command called <code>sudo</code>. sudo stands for ‘super user do’, and it means ‘do the next thing as an administrator’. you can use <code>sudo &lt;whatever&gt;</code> for a single command, or enter interactive mode with <code>sudo -i</code>. in interactive mode, <em>all</em> your commands will be admin commands, until you say <code>exit</code>.</p>
<p><span class="emoji" data-emoji="warning">⚠️</span> <strong>there is no undo button! if you say something with sudo, make sure you mean it!</strong></p>
<p>throughout this guide, I’ll be using <code>$</code> at the start of a command if you run it as a normal user, or <code>#</code> if you run it as admin. either way, you don’t actually type this symbol yourself, it should already appear on your command line.</p>
<p>we’ll need to do these things before we can go headless:</p>
<ul>
<li>change <code>sudo</code> to require a password</li>
<li>change the hostname from the default</li>
<li>connect to a network</li>
<li>enable remote login</li>
<li>install operating system updates</li>
<li>reboot</li>
</ul>
<p>first we’ll change the sudo rules for our account. there should be a config file at <code>/etc/sudoers.d/010_pi-nopasswd</code>. we’ll use the special <code>visudo</code> command to edit it, which should launch <code>nano</code> like before, but with special safety guards to catch us if we lock ourselves out of administrator mode.</p>
<pre><code>$ sudo visudo /etc/sudoers.d/010_pi-nopasswd</code></pre>
<p>you should see a single line, like</p>
<pre><code>user ALL=(ALL) NOPASSWD: ALL</code></pre>
<p>remove the <code>NOPASSWD:</code> instruction, so this file reads</p>
<pre><code>user ALL=(ALL) ALL</code></pre>
<p>save and quit. from now on, if you haven’t used <code>sudo</code> in a few minutes, the system will ask for your password. this way if you accidentally leave yourself logged in, and someone else takes over your session, they won’t automatically get sudo access.</p>
<p>we can do the next few steps with the <code>raspi-config</code> tool.</p>
<pre><code>$ sudo raspi-config</code></pre>
<p>the hostname is under System Options -&gt; Hostname. I set mine to ‘teapot’.</p>
<p>if your machine is plugged directly into your home router with a patch cable, you already have network access, otherwise set up wireless with System Options -&gt; Wireless LAN.</p>
<p>to log in remotely, go to Interface Options -&gt; SSH.</p>
<p>select ‘Finish’. you’ll be prompted to reboot, but don’t yet, we’ll reboot later after installing some updates. in Debian Linux, we update packages using a tool called <code>apt</code>. <code>apt update</code> checks for updated packages, and <code>apt upgrade</code> installs them. run both these commands now, using the interactive version of <code>sudo</code>.</p>
<pre><code>$ sudo -i
# apt update
# apt upgrade</code></pre>
<p>finally, if you’re on a Raspberry Pi, then <code>avahi-daemon</code> is installed automatically. if not, you may need to install it yourself. this program broadcasts your hostname to the network, so you can log in remotely without configuring anything on your router.</p>
<pre><code># apt install avahi-daemon</code></pre>
<p>now go ahead and reboot, to make sure your new hostname is in use.</p>
<pre><code># reboot</code></pre>
<p>after a minute, you should now be able to log in remotely from another computer, using</p>
<pre><code>$ ssh user@teapot</code></pre>
<p>or</p>
<pre><code>$ ssh user@teapot.local</code></pre>
<p>if this works, congrats! you can now unplug the keyboard and monitor. you’ve created a headless server.</p>
</section>
<section id="format-storage" class="level2">
<h2>format storage</h2>
<p>the Raspberry Pi uses a MicroSD card as the operating system disk. it’s convenient; if the OS breaks you can just pull its brain out, factory reset it, and pop it back in. however, I don’t want to store all my user data on that brain card. I think it’s better if you have a secondary disk that contains <em>only</em> the stuff you create yourself. that way if something goes wrong and you have to reset the brain card, you don’t lose any of your personal data.</p>
<p>there are different formats for a data disk. the format determines exactly where the data and metadata will appear in each ‘chunk’ of the disk. Windows typically uses <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>, which supports metadata for ownership and last modified time, but not for fine-grained access like whether a file is shared with guests. Linux uses a format that does allow this fine-grained access, called <a href="https://en.wikipedia.org/wiki/Ext4">ext4</a>, so that’s what we need to format the data disk as.</p>
<p>first we need to identify the disk’s device file. in Linux, everything you can read or write to is treated as a file, including a USB device like an external disk. note that this device file is <em>not</em> the same as a filesystem mount. we’ll cover mounting later.</p>
<p>with the data disk unplugged, run the command <code>fd</code>. plug the disk in, and run <code>fd</code> again. compare its output to the previous run. there should be exactly one new entry, and it should look like <code>/dev/sda</code> or <code>/dev/sda2</code>. if you’re not sure which disk it is, don’t risk it, ask a friend for help.</p>
<!-- todo: where can you find a friend to ask? -->
<p><span class="emoji" data-emoji="warning">⚠️</span> <strong>warning! this will erase everything on the disk!</strong></p>
<p>format the disk, and label it. this will make it easier to mount later.</p>
<pre><code># mkfs.ext4 /dev/sda
# e2label /dev/sda teapot-data</code></pre>
</section>
<section id="mount-storage" class="level2">
<h2>mount storage</h2>
<p>Linux doesn’t use drive letters like Windows does. instead, every disk’s filesystem lives at some <strong>path</strong>. the main, or ‘root’ path is <code>/</code>, a single slash. the root path belongs to the operating system disk, in this case the MicroSD card. we’ll create a new sub-path at <code>/data</code> for our data disk.</p>
<pre><code># mkdir /data</code></pre>
<p>when the system boots up, it looks in the config file <code>/etc/fstab</code> to find out where we want other filesystems to be loaded. since we gave our disk a label earlier, we can mount it using that label. open the file with <code>nano</code>, and add this line to the end of it:</p>
<pre><code>LABEL=teapot-data /data ext4 nofail,x-systemd.device-timeout=5s,x-systemd.automount 0 0</code></pre>
<p>there’s a lot going on here. you can <a href="https://www.freedesktop.org/software/systemd/man/systemd.mount.html#fstab">read more</a> about how fstab and systemd work, but basically what we’re saying is</p>
<ul>
<li>find the disk labeled ‘teapot-data’ and mount it at <code>/data</code>, as an ext4 filesystem.</li>
<li>nofail: if the disk is missing at boot time, skip it and finish booting anyway.</li>
<li>x-systemd.device-timeout=5s: wait 5 seconds before giving up.</li>
<li>x-systemd.automount: if someone tries to access the disk and it’s not mounted, try mounting it again.</li>
</ul>
<p>we’re using a delayed mounting process here because we want to make sure our server still comes online, even if the disk fails to load. if the server crashes on boot, we’ll have to go plug the monitor and keyboard back in to fix it. with nofail, we have a chance to fix it remotely.</p>
<p>save and exit the file if you haven’t already, and then check it:</p>
<pre><code># mount --all --fake --verbose</code></pre>
<ul>
<li>–all: apply all the rules from <code>/etc/fstab</code>.</li>
<li>–fake: don’t <em>actually</em> apply the rules, just check that they’re written correctly.</li>
<li>–verbose: give detailed feedback. Linux programs typically say nothing unless there is an error.</li>
</ul>
<p>if all your mounts pass inspection, now is a good time to reboot the machine.</p>
<pre><code># reboot</code></pre>
</section>
<section id="backups" class="level2">
<h2>backups</h2>
<p>I’ll write a longer section about backups later. basically: every month or so, plug in the second disk, and copy everything from the first disk to the second one. it’s a quick and dirty solution and it’s better than having no backups at all. the command you want is</p>
<pre><code>rsync -axHAWXS --numeric-ids --info=progress2 &lt;source&gt; &lt;destination&gt;</code></pre>
<p>explanation <a href="https://superuser.com/a/1185401">here</a>.</p>
</section>
<section id="website" class="level2">
<h2>website</h2>
<p>we’re getting into the fun stuff now. one of the coolest things you can do with your Linux server is host a website. a little chunk of the world wide web that belongs just to you. all you need to be a website is to have a program running and ready to answer <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> requests with <a href="https://en.wikipedia.org/wiki/HTML">HTML</a> text. HTTP is the HyperText Transfer Protocol, and ‘HyperText’ is just a fancy word for ‘text with <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a">hyperlinks</a> in it’.</p>
<p>put briefly: the internet is made of programs that exchange text files with each other!</p>
<p>we could write a web server from scratch, but to get started we’ll use <a href="https://httpd.apache.org">Apache</a>, a free, open-source, and well-established web server. <a href="https://nginx.org">nginx</a> has a free version too, but Apache is good enough for our purposes.</p>
<pre><code># apt install apache2</code></pre>
<p>it should start itself automatically. go ahead and check <a href="http://teapot.local" class="uri">http://teapot.local</a>, and you should see the test page! now we’ll write our own page hosted on the data disk. we’ll make a folder for it called <code>/data/teapot.local</code> and a subfolder of that called <code>site</code>.</p>
<pre><code># mkdir /data/teapot.local
# mkdir /data/teapot.local/site</code></pre>
<p>when making multiple levels of new directories like this, you can use this shortcut to create the whole chain in one go:</p>
<pre><code># mkdir -p /data/teapot.local/site</code></pre>
<p>we’re about to do a bunch of typing to set up a basic site definition. you can copy and paste this if you want, but I recommend typing it by hand. it’ll train your brain to recognize pieces of the code. remember, use <code>nano</code> to create or edit text files.</p>
<p>contents of <code>/data/teapot.local/site.conf</code>:</p>
<pre><code>&lt;VirtualHost *:80&gt;

ServerName teapot.local
DocumentRoot /data/teapot.local/site

&lt;Directory /&gt;
  Require all granted
&lt;/Directory&gt;

&lt;/VirtualHost&gt;</code></pre>
<p>this is just about the simplest possible website definition. we’re saying “hi, I am a web server listening to port 80, serving pages for the website ‘teapot.local’.” a <strong>port</strong> is like a post office box for a computer. it allows you to address a specific program inside the machine. port 80 is an old and well-known port which is used for most HTTP traffic.</p>
<p>next we define the DocumentRoot to be <code>/data/teapot.local/site</code>, instead of Apache’s default of <code>/var/www/html</code>. we also tell Apache that it’s allowed to share these files. by default, if no filename is specified, Apache will look for one called <code>index.html</code>, so we’ll write that too.</p>
<p>contents of <code>/data/teapot.local/site/index.html</code>:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;title&gt;my website!&lt;/title&gt;
&lt;h1&gt;my website!&lt;/h1&gt;
lorem ipsum dolor sit amet</code></pre>
<p>HTML is what your web browser sees. in fact, if you’re on a desktop browser, you can press ctrl-u right now to see the HTML text behind <em>this page!</em> what I’ve written for this example is the bare minimum to follow the modern html5 standard.</p>
<ul>
<li>originally the <code>&lt;!DOCTYPE&gt;</code> tag was used to announce what version of html you were using, but these days we don’t really care. we just assume everyone’s using ‘normal’ html.</li>
<li>the <code>&lt;html&gt;</code> tag is traditional, but in html5 it’s actually <a href="https://html.spec.whatwg.org/multipage/semantics.html#the-html-element">optional</a>, as is the closing <code>&lt;/html&gt;</code> tag. we include the opening tag here so we can specify <code>lang="en"</code>, which tells the browser that our website is written in English. if you are not writing in English, substitute the appropriate <a href="https://www.w3schools.com/tags/ref_language_codes.asp">language code</a>.</li>
<li>use a <code>&lt;meta&gt;</code> tag to let the browser know we’re using utf-8. once upon a time there were different text encodings for every language. it’s really a <a href="https://www.youtube.com/watch?v=MijmeoH9LT4">miracle</a> that utf-8 exists. this encoding was written by the geniuses at <a href="https://home.unicode.org">Unicode</a>. it works great for English, and pretty well for <em>every other text in every known language.</em> if this emoji works (⚠️) and isn’t displayed like aE` or something, then you can thank utf-8.</li>
<li>a title! the <code>&lt;title&gt;</code> tag is required in html5. this is the text that appears in your browser tab.</li>
<li>a heading! this is usually the same as the title, but it’s optional. <code>&lt;h1&gt;</code> is used for the main heading, <code>&lt;h2&gt;</code> for a sub-heading, all the way down to <code>&lt;h6&gt;</code>.</li>
<li>finally, I put some <a href="https://www.lipsum.com">generic text</a> here with no tags at all, just to pad out the page a little.</li>
</ul>
<p>once you’ve written both of those files, we can tell Apache our site is ready. by the way, when typing these long paths, try pressing ‘tab’ once or twice, sometimes your shell will auto-complete words. neat!</p>
<pre><code># ln -s /data/teapot.local/site.conf /etc/apache2/sites-available/teapot.local.conf
# a2ensite teapot.local
# a2dissite 000-default
# systemctl reload apache2</code></pre>
<p>now go back to <a href="http://teapot.local" class="uri">http://teapot.local</a> and hit refresh, and you should see your new website! at this point you can go explore the world of HTML. the nice folks at <a href="https://neocities.org/tutorials">Neocities</a> are helping to keep this art alive, go check them out! and remember, you can press ctrl-u to view the HTML for any page you’re on.</p>
<p><em>p.s. up until this point I’ve been writing with pure HTML myself, but as this page is getting rather long, I’m actually switching to a helper tool called <a href="https://pandoc.org/">pandoc</a>. I may cover this tool in a later tutorial.</em></p>
</section>
</body>
</html>

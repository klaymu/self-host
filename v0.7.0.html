<!doctype html>
<html lang="en">
<meta charset="utf-8">
<link rel="stylesheet" href="style-v0.6.0.css">
<title>
klay's simple cookbook for Linux
</title>

<nav>
<a href="/">home</a>
| <a href=".">latest</a>
| <a href="v0.5.2">v0.5.2</a>
| <a href="v0.6.0">v0.6.0</a>
</nav>

<h1>klay's simple cookbook for Linux, v0.7.0</h1>

<section>
<h2>audience</h2>
who is this guide for? me, mostly. but more broadly it's for anyone who wants to host their own web server and understand how it works.
<p>
there's an old <a href="https://www.reddit.com/r/geek/comments/4zl3e1/happy_birthday_linux_heres_your_cake/">joke</a> that using Linux is like ordering a cake and receiving a bunch of flour, sugar, butter, and eggs. many self-hosting tutorials read like the back of a box of cake mix, which is great if you want a cake fast, but unsatisfying if you want to learn about cake making. my goal is for this guide to teach you enough to improvise, to make substitutions. this isn't just a recipe, this is a cookbook.
<p>
let's get cooking.
</section>

<section>
<h2>materials</h2>
I'll be using a <a href="https://www.raspberrypi.com/">Raspberry Pi 4b</a> and installing <a href="https://www.armbian.com/">armbian v23.5.1</a>. if the Raspberry Pi isn't available where and when you are, check out the <a href="https://libre.computer/products/roc-rk3328-cc/">Renegade</a> or the <a href="https://www.pine64.org/devices/single-board-computers/rock64/">ROCK64</a>. you'll also need a MicroSD card, I recommend 64GB, and a hard drive, I recommend 2TB, plus a second hard drive for backup. the Pi can just about power one hard drive on its own, but if you want to plug both in at once you'll need a powered hard drive enclosure or a powered usb hub.
<p>
you can adapt these directions to any machine that can run <a href="https://www.debian.org/doc/">Debian</a>, like an old laptop or desktop pc. you can also rent a virtual machine running in a remote datacenter. the cheapest virtual machine on <a href="https://www.digitalocean.com/">DigitalOcean</a> is only $6/mo (as of July 2023), and comes with 25GB of storage. renting a machine in a datacenter means you get the perks of high-speed internet all day and night, great if you're running a game server and need a fast connection. however, you'll pay about $10/mo for every additional 100GB of storage, so it's not great if you want to host a huge media archive.
</section>

<section>
<h2>operating system</h2>
first, download and install the operating system. there are lots of guides on how to install Linux already, <a href="https://docs.armbian.com/User-Guide_Getting-Started/">here's</a> one for armbian. you may need to plug in an external keyboard and monitor for this step. we can unplug those later, giving us a CLI or "headless" server. 
<p>
the installation should walk you through creating a new username and password, I recommend <a href="https://xkpasswd.net/s/">a long random phrase</a>. write it down. you can't hack a piece of paper.
<p>
log in as 'root', the built-in administrator account. if your install guide doesn't provide a root login, then use this command. "sudo" asks for temporary admin permission, and "su" stands for "switch user".
<pre>
$ sudo su root
</pre>
throughout this guide, I'll be using <code>$</code> at the start of a command if you run it as a normal user, or <code>#</code> if you run it while logged in as root. either way, you don't actually type this symbol yourself, it should already appear on your command line.
<p>
once you're logged in as root, do some system updates. 'apt' is the package manager built into Debian, it holds all your system software and lots of fun optional stuff too.
<pre>
# apt update
# apt upgrade
</pre>
next, set your hostname. this is how you will appear to other computers on the network. for this example I'll use 'teapot'.
<pre>
# hostnamectl set-hostname teapot
</pre>
I'd like to be able to connect to this machine using its hostname. there's a tool for this called 'avahi-daemon'.
<pre>
# apt install avahi-daemon
</pre>
this is a good time to reboot, to make sure the updated hostname is in use:
<pre>
# reboot
</pre>
you should now be able to log into the server from another machine, with
<pre>
$ ssh yourname@teapot
</pre>
or
<pre>
$ ssh yourname@teapot.local
</pre>
</section>

<section>
<h2>format storage</h2>
the Raspberry Pi uses a MicroSD card as the operating system disk. it's clever; if the os breaks you can just pull its brain out, factory reset it, and pop it back in. however, I don't want to store all my user data on that brain card. I think it's better if you have a secondary disk that contains <em>only</em> the stuff you create yourself. that way if something goes wrong and you have to reset the brain card, you don't lose any of your pictures or music or whatever.
<p>
there are different formats for a data disk. the format determines exactly where the data and metadata will appear in each 'chunk' on the disk. windows typically uses <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>, which supports metadata for ownership and modified time, but not for fine-grained access like whether guests are allowed to open the file in read-only mode. Linux uses a format that does allow this fine-grained access, called <a href="https://en.wikipedia.org/wiki/Ext4">ext4</a>, so that's what we need to format our data disk as.
<p>
first we need to identify the disk's device file. in Linux, everything you can read or write to is treated as a file, including a usb device like an external disk. note that this device file is not the same as a filesystem mount. we'll cover mounting later.
<p>
unplug the disk. run the command <code>fd</code>. plug the disk back in. run <code>fd</code> again, and compare its output to before. there should be exactly one new entry, and it should look like <code>/dev/sda</code> or <code>/dev/sdb2</code>. if you're not sure which disk it is, don't risk it, phone a friend. 
<p>
<strong>⚠️ warning! this will erase everything on the disk!</strong>
<p>
format the disk:
<pre>
$ sudo mkfs.ext4 /dev/sda
</pre>
and label it:
<pre>
$ sudo e2label /dev/sda teapot-data
</pre>
</section>

<section>
<h2>mount storage</h2>
Linux doesn't use drive letters like Windows does. Instead, every disk's filesystem lives at some <em>path</em>. the main, or "root" path is <code>/</code>, a single slash, and usually belongs to the main disk, in this case the MicroSD card. we'll create a new path at <code>/data</code> for our data disk.
<p>
<pre>
$ sudo mkdir /data
</pre>
when the system boots up, it looks in the system file <code>/etc/fstab</code> to find out what disks live at what paths. since we gave our disk a label earlier, we can mount it using that label. 
<p>
edit fstab:
<pre>
$ sudo nano /etc/fstab
</pre>
add this line:
<pre>
LABEL=teapot-data /data ext4 nofail,x-systemd.device-timeout=5s,x-systemd.automount 0 0
</pre>
there's a lot going on here. you can <a href="https://www.freedesktop.org/software/systemd/man/systemd.mount.html#fstab">read more</a> about how fstab and systemd work together, but basically what we're saying is:
<ul>
    <li>find the disk labeled "teapot-data" and mount it at /data, as an ext4 filesystem.</li>
    <li>nofail: if the disk is missing at boot time, skip it and finish booting anyway.</li>
    <li>x-systemd.device-timeout=5s: wait 5 seconds before giving up.</li>
    <li>x-systemd.automount: if someone tries to access the disk and it's not mounted, try mounting it again.</li>
</ul>
we're using a delayed mounting process here because we want to make sure our server still comes online, even if the disk fails to load. if the server crashed on boot we'd have to go physically plug in a keyboard and monitor to fix it. with nofail, we can still log in remotely.
<p>
save and exit the file if you haven't already, then check it:
<pre>
$ sudo mount --all --fake --verbose
</pre>
<ul>
    <li>--all: apply all the rules from <code>/etc/fstab</code>.</li>
    <li>--fake: don't <em>actually</em> apply the rules, just check that they're written correctly.</li>
    <li>--verbose: give detailed feedback. Linux programs typically say nothing unless there is an error.</li>
</ul>
if all your mounts pass inspection, now is a good time to reboot the machine.
<pre>
$ sudo reboot now
</pre>
</section>

<section>
<h2>backups</h2>
I'll write a longer section about backups later, but basically: buy a second disk, and every month or so, copy the entirety of the first disk to the second one. it's a quick and dirty solution and it's better than having no backups at all. the command you want is
<pre>
rsync -axHAWXS --numeric-ids --info=progress2 &lt;source&gt; &lt;dest&gt;
</pre>
explanation <a href="https://superuser.com/a/1185401">here</a>.
<p>
</section>

<section>
<h2>website</h2>
the most exciting thing you can do with your Linux server is host a website. a little chunk of the world wide web that belongs just to you. all you need to be a website is to have a program running and ready to answer <a href="https://en.wikipedia.org/wiki/HTTP">HTTP</a> requests with <a href="https://en.wikipedia.org/wiki/HTML">HTML</a> text. HTTP is the HyperText Transfer Protocol, and "HyperText" is just a fancy word for "text with <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a">hyperlinks</a> in it".
<p>
put briefly: the internet is made of programs that exchange text files with each other. that's it.
<p>
we could write a web server from scratch, but to get started we'll use <a href="https://httpd.apache.org/">Apache</a>, a free, open-source, and well-established web server. go ahead and install it. <a href="https://nginx.org">nginx</a> has a free version too, but Apache is good enough for our purposes.
<pre>
$ sudo apt install apache2
</pre>
it should start itself automatically. go ahead and check <a href="http://teapot.local">http://teapot.local</a> and you should see the test page! now we'll write our own page hosted on our data disk. we'll make an Apache config named <code>site.conf</code> and then put our main page at <code>site/index.html</code>.
<pre>
$ sudo mkdir /data/teapot.local
$ sudo mkdir /data/teapot.local/site
</pre>
we're about to do a bunch of typing now. you can copy and paste this if you want, but I recommend re-typing it by hand. it'll train your brain to recognize pieces of the code, which will be a good skill to have later. remember you can use <code>nano</code> to create or edit text files.
<p>
contents of <code>/data/teapot.local/site.conf</code>:
<pre>
&lt;VirtualHost *:80&gt;

ServerName teapot.local
DocumentRoot /data/teapot.local/site

&lt;Directory /&gt;
    Require all granted
&lt;/Directory&gt;

&lt;/VirtualHost&gt;
</pre>
this is just about the simplest possible website definition. we're saying "hi, I am a web server listening to port 80, serving pages for teapot.local." a <strong>port</strong> is like a post office box for a computer, it allows you to address a specific program inside the machine. port 80 is an old and well-known port which is used for most http traffic.
<p>
next we define the DocumentRoot to be <code>/data/teapot.local/site</code>, instead of Apache's default of <code>/var/www/html</code>. we also tell Apache that it's allowed to share these files. by default, if no filename is specified, Apache will look for one called <code>index.html</code>, so we'll write that next.
<p>
contents of <code>/data/teapot.local/site/index.html</code>:
<pre>
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;My Website&lt;/title&gt;
&lt;h1&gt;My Website&lt;/h1&gt;
lorem ipsum dolor sit amet
</pre>
this is the fun stuff. HTML is what your browser sees. in fact, if you're on a desktop browser, you can press ctrl-u right now to see the HTML text behind <em>this page!</em> what I've written for this example is more or less the bare minimum to follow the modern html5 standards.
<ul>
    <li>originally the <code>&lt;!doctype&gt;</code> tag was used to announce what version of html you were using, but these days we don't really care, we just assume everyone's using 'normal' html.</li>
    <li>the <code>&lt;html&gt;</code> tag is traditional, but in html5 it's <a href="https://html.spec.whatwg.org/multipage/semantics.html#the-html-element">actually optional</a>, as is the closing <code>&lt;/html&gt;</code> tag. we include it here just so we can specify <code>lang="en"</code>, telling the browser that our website is written in english. if you are not writing in english, substitute the appropriate <a href="https://www.w3schools.com/tags/ref_language_codes.asp">language code</a>.</li>
    <li>let the browser know we're using utf-8. once upon a time there were different text encodings for every language. it's really <a href="https://www.youtube.com/watch?v=MijmeoH9LT4">a miracle</a> that utf-8 exists. this encoding was written by the geniuses at <a href="https://home.unicode.org/">Unicode</a>. it works great for english and pretty well for <em>all other text in every known language</em>. if this emoji works (⚠️) and isn't displayed like aE` or something, then you can thank utf-8.</li>
    <li>a title! every website is required to have a title. this is the thing that appears in your browser tab.</li>
    <li>a heading! this is usually the same as the title, but it's not required. <code>&lt;h1&gt;</code> is used for the main heading, <code>&lt;h2&gt;</code> for sub-headings, all the way down to <code>&lt;h6&gt;</code>.</li>
    <li>finally, I put some <a href="https://www.lipsum.com/">generic text</a> here with no tags at all, just to pad out the page a little.</li>
</ul>
once you've written both of those files, we can tell Apache our site is ready.
<pre>
$ sudo ln -s /data/teapot.local/site.conf /etc/apache2/sites-available/teapot.local.conf
$ sudo a2ensite teapot.local
$ sudo a2dissite 000-default
$ sudo systemctl reload apache2
</pre>
okay, go back to <a href="http://teapot.local">http://teapot.local</a> and hit refresh, and you should see your new website! at this point you can go explore the world of html! the nice folks at <a href="https://neocities.org/tutorials">Neocities</a> are helping to keep this art alive, go check out their site. and remember: you can always press ctrl-u to see the HTML for any page you're on.
<p>
</section>

<section>
<h2>networking</h2>
hey uh your website won't work outside your local network until you do this but I haven't written a guide yet so go look up "port forwarding", thanks
<p>
todo
<ul>
    <li>set up a firewall using ufw</li>
    <li>set up port forwarding on your router</li>
    <li>don't forget hairpin NAT</li>
    <li>get a domain name</li>
    <li>set up https</li>
    <li>i might have to make this an entirely separate tutorial</li>
</ul>
</section>

<section>
<h2>containers</h2>
at this point, we'll take a detour and talk about containers. everything we've done so far has involved making changes to system files. if you need to copy your data to a new system you'll have to change all those system files again, and this gets more complicated the more things are installed. thankfully, most useful applications can now be installed as <strong>containers</strong>.
<p>
a <strong>container</strong> isn't quite a virtual machine, you're not running a whole computer-inside-a-computer. it's basically just a cardboard box with a fake filesystem and network. they don't take a ton of memory to create, and they don't leave junk all over the filesystem when you remove them. neat!
<p>
we'll be using <a href="https://podman.io/">Podman</a>, a container host service. if you're familiar with <a href="https://www.docker.com/">Docker</a>, this is like that, but like, even <em>more</em> free.
<pre>
$ sudo apt install podman uidmap slirp4netns python3-pip
$ sudo pip install podman-compose=1.0.3
</pre>
<ul>
    <li>uidmap: needed to make fake users inside a container, necessary when running a container <strong>rootless</strong>, without sudo.</li>
    <li>slirp4netns: used to make private networks between containers.</li>
    <li>python3-pip: an alternative package manager specifically for <a href="https://www.python.org/">Python</a> programs, we need this to install <a href="https://github.com/containers/podman-compose#podman-compose">podman-compose</a>.</li>
    <li>podman-compose: a very handy tool that lets you store your container instructions in a script file to use later, we'll cover this soon. I needed to specify v1.0.3 because of <a href="https://github.com/containers/podman-compose/issues/637">conflicts</a> with <a href="https://github.com/containernetworking/cni">cni</a>, the container network interface library.</li>
</ul>
let's test it out by running <a href="https://nginx.org/">nginx</a> (pronounced 'engine-x'), a simple and fast web server. we'll use the image published by <a href="https://hub.docker.com/">Docker Hub</a>. think of an <strong>image</strong> as a photo negative or a resin mold: you can't run an image directly, but you can use it to produce a filled container.
<pre>
$ podman run --rm -p 9000:80 docker.io/library/nginx
</pre>
<ul>
    <li>podman run: create a new container and start it immediately.</li>
    <li>--rm: remove the container automatically when the main program exits.</li>
    <li>-p 9000:80: connect port 9000 on the host to port 80 inside the container. we need permission to bind to ports less than 1024, since they're older and have special meanings. without that permission, we can use any port between 1024 and 65535. 9000 is an arbitrary, easy-to-remember choice.</li>
    <li>docker.io/library/nginx: the name of the image we're building. this has to come last, because anything that comes after the image name is instructions for the program inside the container, not for podman. in this case we're not giving any instructions after the image name though, because we want to run the default command for this image.</li>
</ul>
if you get an error like "delete libpod local files to resolve", then you may need to do this extra step, then try again:
<pre>
$ sudo rm ~/.local/share/containers
</pre>
otherwise, you should now be able to point a web browser at <a href="http://teapot.local:9000">http://teapot.local:9000</a> and you will see the nginx test page!
<p>
finally, we'll use podman-compose to save our setup. create a folder in <code>/data</code> for this container, and make a new file called <code>compose.yaml</code>.
<pre>
$ sudo mkdir /data/nginx
$ cd /data/nginx
$ sudo nano compose.yaml
</pre>
contents of <code>compose.yaml</code>:
<pre>
version: '3'
services:
  nginx:
    image: docker.io/library/nginx
    ports:
      - 9000:80
</pre>
this does the same thing as our command from before. it starts one service container, running nginx, with port 9000 on the host mapped to port 80 in the container. to run this script, type
<pre>
$ sudo podman-compose up -d
</pre>
and to stop it again:
<pre>
$ sudo podman-compose down
</pre>
</section>

<section>
<h2>database</h2>
todo
<ul>
    <li>explain why and how to host a database</li>
    <li>install php and mariadb</li>
    <li>configure phpmyadmin</li>
</ul>
</section>

<section>
<h2>file sharing</h2>
todo
<ul>
    <li>install syncthing</li>
    <li>set up samba share</li>
    <li>configure nfs</li>
    <li>uhhh webdav maybe</li>
</ul>
</section>

<section>
<h2>apps</h2>
todo
<ul>
    <li>recommend some other apps like gitea, freshrss, etc.</li>
    <li>serve an app through nginx proxy_pass</li>
</ul>
</section>

<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>
klay mu's quick guide to self-hosting
</title>
<style>
    :root {
        font-family: Calibri, sans-serif;
        color: lightgray;
        background-color: black;
        max-width: 100ch;
        margin: auto;
    }
    a {
        color: deepskyblue;
    }
    a:visited {
        color: deeppink;
    }
    code {
        color: lightgreen;
        font-size: 1rem;
    }
    pre {
        color: lightgreen;
        font-size: 1rem;
        margin-left: 2ch;
        white-space: pre-wrap;
    }
    section {
        border-top: lightgray solid 0.5ch;
    }
</style>
<h1>klay mu's quick guide to self-hosting, v0.4.4</h1>

<section>
<h2>materials</h2>
<p>
    I'm using a <a href=
    "https://www.raspberrypi.com/">Raspberry Pi</a>, but if those aren't available where and when you are, a good alternative is the <a href="https://www.pine64.org/devices/single-board-computers/rock64/">ROCK64</a>. you'll also need a MicroSD card and an external hard drive, I recommend 64GB and 2TB respectively.
</p>
</section>

<section>
<h2>operating system</h2>
<p>
first, go ahead and install whatever flavor of Linux you're going to use, I recommend <a href="https://www.armbian.com/">armbian</a>. follow the installation steps for your device. you may need to plug in an external keyboard and monitor for this step. the installation should walk you through creating a new username and password, I recommend a <a href="https://xkcd.com/936/">long but memorable phrase</a>.
<p>
after installing the os is a good time do to some initial setup. while you're connected as root, update your installed packages:
<p>
<pre>
# apt update
# apt upgrade
</pre>
<p>
set your hostname, this is how you will appear to other computers on the network. for this example I'll use 'teapot'.
<p>
<pre>
# hostnamectl set-hostname teapot
</pre>
<p>
I'd like to be able to connect to this hostname via LAN, too. there's a tool for this called 'avahi-daemon'.
<p>
<pre>
# apt install avahi-daemon
</pre>
<p>
this is a good time to reboot, to make sure the updated hostname is in use:
<p>
<pre>
# reboot
</pre>
<p>
you should now be able to ssh into the server from another machine, with
<p>
<pre>
ssh yourname@teapot
</pre>

    or

<pre>
ssh yourname@teapot.local
</pre>
</section>

<section>
<h2>format storage</h2>
<p>
the Raspberry Pi and the ROCK64 both use a MicroSD card as the operating system disk. it's clever; if the os breaks you can just pull its brain out, factory reset it, and pop it back in. however, I don't want to store all my user data on that brain card. I think it's better if you have a secondary disk that contains <em>only</em> the stuff you create yourself. that way if something goes wrong and you have to reset the brain card, you don't lose any of your pictures or music or whatever.
<p>
there are different formats for a data disk. the format determines exactly where the data and metadata will appear in each 'chunk' on the disk. windows typically uses <a href="https://en.wikipedia.org/wiki/NTFS">NTFS</a>, which supports metadata for ownership and modified time, but not for fine-grained access like whether guests are allowed to open the file in read-only mode. Linux uses a format that does allow this fine-grained access, called <a href="https://en.wikipedia.org/wiki/Ext4">ext4</a>, so that's what we need to format our data disk as.
<p>
<strong>⚠️ warning! this will erase everything on the disk!</strong>
<p>
first we need to identify the disk's device file. in Linux, everything you can read or write to is treated as a file, including a usb device like an external disk. note that this device file is not the same as a filesystem mount. we'll cover mounting later.
<p>
unplug the disk. run the command <code>fd</code>. plug the disk back in. run <code>fd</code> again, and compare its output to before. there should be exactly one new entry, and it should look like <code>/dev/sda</code> or <code>/dev/sdb2</code>. if you're not sure which disk it is, don't risk it, phone a friend. 
<p>
format the disk:
<p>
<pre>
$ sudo mkfs.ext4 /dev/sda
</pre>
<p>
and label it:
<p>
<pre>
$ sudo e2label /dev/sda teapot-data
</pre>
</section>

<section>
<h2>mount storage (updated in v0.4.4)</h2>
<p>
Linux doesn't use drive letters like Windows does. Instead, every disk's filesystem lives at some <em>path</em>. the "main" path is <code>/</code>, a single slash, and usually belongs to the main disk, in this case the MicroSD card. we'll create a new path at <code>/data</code> for our data disk.
<p>
<pre>
$ sudo mkdir /data
</pre>
<p>
when the system boots up, it looks in the system file <code>/etc/fstab</code> to find out what disks live at what paths. since we gave our disk a label earlier, we can mount it using that label. 
<p>
edit fstab:
<p>
<pre>
$ sudo nano /etc/fstab
</pre>
<p>
add this line:
<p>
<pre>
LABEL=teapot-data /data ext4 nofail,x-systemd.device-timeout=5s,x-systemd.automount 0 0
</pre>
<p>
there's a lot going on here. you can <a href="https://www.freedesktop.org/software/systemd/man/systemd.mount.html#fstab">read more</a> about how fstab and systemd work together, but basically what we're saying is:
<ul>
    <li>find the disk labeled "teapot-data" and mount it at /data, as an ext4 filesystem.</li>
    <li>nofail: if the disk is missing at boot time, skip it and finish booting anyway.</li>
    <li>x-systemd.device-timeout=5s: wait 5 seconds before giving up.</li>
    <li>x-systemd.automount: if someone tries to access the disk and it's not mounted, try mounting it again.</li>
</ul>
<p>
we're using a delayed mounting process here because we want to make sure our server still comes online, even if the disk fails to load. if the server crashed on boot we'd have to go physically plug in a keyboard and monitor to fix it. with nofail, we can still log in remotely.
<p>
save and exit the file if you haven't already, then check it:
<p>    
<pre>
$ sudo mount --all --fake --verbose
</pre>
<ul>
    <li>all: apply all the rules from <code>/etc/fstab</code>.</li>
    <li>fake: don't <em>actually</em> apply the rules, just check that they're written correctly.</li>
    <li>verbose: give detailed feedback. Linux programs typically say nothing unless there is an error.</li>
</ul>
<p>
if all your mounts pass inspection, now is a good time to reboot the machine:
<p>
<pre>
$ sudo reboot now
</pre>
</section>

<section>
<h2>apps (updated in v0.5.0)</h2>
<p>
at this point, we'll take a detour and talk about containers. everything we've done so far has involved making changes to system files. if you need to copy your data to a new system you'll have to change all those system files again, and this gets more complicated the more things are installed. thankfully, most useful applications can now be installed as <strong>containers</strong>, which <em>contain</em> all their own data and system files. think of the host machine as a <a href="https://www.ikea.com/us/en/cat/kallax-shelving-units-58285/">shelf</a>, and each container as a cubby on that shelf. this added structure keeps apps from touching each other's files, and makes it easier to remove things later.
<p>
we'll be using <a href="https://podman.io/">Podman</a>, a container host service that allows you to work with either individual containers, or with groups of containers called <strong>pods</strong>. in our shelf analogy, a pod is a cubby which has been sub-divided into <a href="https://www.ikea.com/us/en/cat/inserts-accessories-for-kallax-58286/">more cubbies</a>, but still takes up a single space on the original shelf.
<p>
podman has a few optional packages that I recommend, we'll install them all now:
<p>
<pre>
$ sudo apt install podman uidmap slirp4netns python3-pip
$ sudo pip install podman-compose==1.0.3
</pre>
<ul>
    <li>uidmap: needed to make fake users inside a container, necessary when running a container <strong>rootless</strong>, without sudo.</li>
    <li>slirp4netns: used to make private networks between containers.</li>
    <li>python3-pip: an alternative package manager specifically for <a href="https://www.python.org/">Python</a> programs, we need this to install <a href="https://github.com/containers/podman-compose#podman-compose">podman-compose</a>.</li>
    <li>podman-compose: a very handy tool that lets you store your container instructions in a script file to use later, we'll cover this soon!</li>
</ul>
<p>
let's test it out by running <a href="https://nginx.org/">nginx</a> (pronounced 'engine-x'), a simple and fast web server. we'll use the image published by <a href="https://hub.docker.com/">Docker Hub</a>. think of an <strong>image</strong> as a photo negative or a resin mold: you can't run an image directly, but you can use it to produce a filled container.
<p>
<pre>
$ podman run --rm -p 9000:80 docker.io/library/nginx
</pre>
<ul>
    <li>podman run: create a new container and start it immediately.</li>
    <li>--rm: remove the container automatically when the main program exits.</li>
    <li>-p 9000:80: connect port 9000 on the host to port 80 inside the container. ports are like the networking equivalent of a post office box or a room number, they allow you to send messages to a specific program inside a machine. web browsers send messages to port 80 by default, so that's what nginx is listening for, but we need permission to bind to ports less than 1024, since they're older and have special meanings. without that permission, we can use any port between 1024 and 65535. 9000 is an arbitrary, easy-to-remember choice.</li>
    <li>docker.io/library/nginx: the name of the image we're building. this has to come last, because anything that comes after the image name is instructions for the program inside the container, not for podman. in this case we're not giving any instructions after the image name though, because we want to run the default command for this image.</li>
</ul>
<p>
if you get an error like "delete libpod local files to resolve", then you may need to do this extra step, then try again:
<p>
<pre>
$ sudo rm ~/.local/share/containers
</pre>
<p>
otherwise, you should now be able to point a web browser at <a href="http://teapot.local:9000">http://teapot.local:9000</a> and you will see the nginx test page!
<p>
now, the final piece: we'll use podman-compose to save our settings for this container. create a folder in <code>/data</code> for this container, and make a new file called <code>compose.yaml</code>.
<p>
<pre>
$ sudo mkdir /data/nginx
$ cd /data/nginx
$ sudo nano compose.yaml
</pre>
<p>
contents of <code>compose.yaml</code>:
<p>
<pre>
version: '3'
services:
  nginx:
    image: docker.io/library/nginx
    ports:
      - 9000:80
</pre>
<p>
this does the same thing as our command from before. it starts one service container, running nginx, with port 9000 on the host mapped to port 80 in the container. to run this script, type
<p>
<pre>
$ sudo podman-compose up -d
</pre>
<p>
and to stop it again:
<p>
<pre>
$ sudo podman-compose down
</pre>
</section>

<!-- <section>
<p>
    host your static web content
    
    <code>$ sudo mv /var/www/html /data/web</code>
    
    <code>$ sudo ln -s /data/web /var/www/html</code>
</p>
</section>

<section>
<h2>database</h2>
<p>
    <strong>todo</strong> install mariadb database service
</p>
</section> -->
